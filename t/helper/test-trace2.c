 *
	return print_usage();
 * [] a trace2 "error" event for each value in argv.
 * test-tool trace2 004child [<child-command-line>]
			die("%s", usage_error);
 * [] that the child exit code is propagated to the parent process "exit"
	return MyOk;

	if (get_i(&rc, argv[0]))
	if (!argv[0] || !*argv[0])
 *    the PERF stream).
static int ut_004child(int argc, const char **argv)
 *    and "atexit" events..
 *     ...
 * [] the "code" field in the "atexit" trace2 event.
			ut_k->ut_usage);
	const char *ut_usage;
 * [] the "code" field in the "atexit" trace2 event.
 * a single "error" event immediately before issuing an "exit" event (such
 *    process.
	return rc;
/*
	{ ut_003error,    "003error",  "<error_message>+" },

#include "argv-array.h"
 */
static struct unit_test ut_table[] = {
static int print_usage(void)
 *
	fn_unit_test *ut_fn;
 * will be called by test-tool.c:cmd_main().

 * Rely on test-tool.c:cmd_main() to call trace2_cmd_exit()
}
			if (!strcmp(argv[0], ut_k->ut_name))
{
 * Send an "error" event with each value in argv.  Normally, git only issues
 */
}
#include "exec-cmd.h"
		die("%s", usage_error);
struct unit_test {
 */
 * [] if the child process is an instrumented executable:
static int ut_006data(int argc, const char **argv)
}
 *    [] this writes various "def_param" events for interesting config values.

{
 *     test-tool trace2 <ut_name_1> <ut_usage_1>
	{ ut_006data,     "006data",   "[<category> <key> <value>]+" },
 * with our result.
	     k++, ut_k = &ut_table[k])
		error("%s", argv[k]);
#include "cache.h"
 * test-tool trace2 005exec version
	int rc;
}
	return 129;

};
 *    [] (optional) the child process attempts to run "git-xyx" as a dashed
 *       depth "dN+1" in the PERF stream).
 *

	argc--; /* skip over "trace2" arg */
}

 * [] the "name" field in the "cmd_name" trace2 event.
{
		argc -= 3;
 * [] the "name" field in the "cmd_name" trace2 event.
	char *endptr;
 * test-tool trace2 004child test-tool trace2 004child test-tool trace2 004child
	for_each_ut (k, ut_k)

		return MyError;
	return 0;

 *    [] the child process emits an "alias" event with "xyz" => "version"
	if (argc % 3 != 0)
	for (k = 0, ut_k = &ut_table[k];	\
 * [] (optional) the file:line in the "exit" event refers to this function.
 * [] the "name" field in the "cmd_name" trace2 event.
	if (!argc)
	int result;
	for (k = 0; k < argc; k++)

 * Test harness can confirm (on platforms with a real exec() function):
{
 *    [] the child process runs "git version" as a child process.
{


 *    [] trace2_cmd_start()       [common-main.c:main()]
/*
 * as in die() or BUG()), but multiple "error" events are allowed.
 *     test-tool trace2 <ut_name_2> <ut_usage_2>
/* clang-format off */

 *
 *
		fprintf(stderr, "\t%s %s %s\n", USAGE_PREFIX, ut_k->ut_name,
 * For example:
/*
 * [] that the child process has multiple component SID (or depth "dN+1"
		trace2_data_string(argv[0], the_repository, argv[1], argv[2]);
		    !argv[2] || !*argv[2])

 *       stream).
	exit(result);
 * So that:
 */
/* clang-format off */
 *
 * [] "def_param" events for all of the "interesting" pre-defined
 *    process (since the Windows compatibility layer fakes an exec() with
	*p_value = strtol(data, &endptr, 10);
typedef int(fn_unit_test)(int argc, const char **argv);
 * test-tool trace2 004child test-tool trace2 001return 0
		return 0;
	struct unit_test *ut_k;
	result = execv_git_cmd(argv);
	argv++;

	const char *ut_name;
 *
}
 *    [] that the child process events have a multiple component SID (or
 * Test harness can confirm:

#define MyOk 0
 * [] TODO talk about process replacement and how it affects SID.

#define MyError 1
 * Issue various trace2 events for testing.
 * config settings.
		die("expect <exit_code>");
 *    [] tracd2_cmd_list_config() [test-tool.c:cmd_main()]
	{ ut_001return,   "001return", "<exit_code>" },
{
 * [] that the outer process has a single component SID (or depth "d0" in
{
#define for_each_ut(k, ut_k)			\
 * [] "def_param" events for all of the "interesting" pre-defined
 * [] the process-exit value.
static int ut_002exit(int argc, const char **argv)
 * [] that "exec" and "exec_result" events are generated for the child
	if (*endptr || errno == ERANGE)
/*
	{ ut_004child,    "004child",  "[<child_command_line>]" },
 * Test harness can confirm:
	return result;
 *
	/*
 * Test harness can confirm:
 * config settings.
 * [] the "name" field in the "cmd_name" trace2 event.
 * For example:
 *
/* clang-format on */
{
 * [] that "child_start" and "child_exit" events are generated for the child.
#include "config.h"
 *       generated by the child process.
	if (!argc)
		"expect <cat0> <k0> <v0> [<cat1> <k1> <v1> [...]]";
#include "run-command.h"
		die("expect <error_message>");
 * test-tool trace2 005exec <git_command_args>
		return 0;
 *    [] the "version" event has been generated.
	{ ut_005exec,     "005exec",   "<git_command_args>" },
 * [] if the child process is like the alias example above,

{
static int ut_001return(int argc, const char **argv)
 * Exec a git command.  This may either create a child process (Windows)
		for_each_ut (k, ut_k)
 */
}
	 * command nesting and let the last one be null.
	exit(rc);
	if (!data || !*data)
 *    [] the child process has a 3 component SID (or depth "d2" in the PERF



 * [] (optional) that the "t_abs" field in the child process "atexit" event


	{ ut_002exit,     "002exit",   "<exit_code>" },

		if (!argv[0] || !*argv[0] || !argv[1] || !*argv[1] ||
	 * Allow empty <child_command_line> so we can do arbitrarily deep
 * We assume that these trace2 routines has already been called:
 * Run a child process and wait for it to finish and exit with its return code.
	}

	while (argc) {
 * test-tool trace2 004child git version
 *    [] the process SID has been created.
 *    [] the various trace2 streams are open.
 *    is less than the "t_rel" field in the "child_exit" event of the parent
#include "test-tool.h"
	fprintf(stderr, "usage:\n");
	const char *usage_error =
 * Usage:
/*
		return MyError;
 */
 * [] the "code" field in the "exit" trace2 event.
 * Cause the process to exit with the requested value via "exit()".
 *       command.
 * Cause process to exit with the requested value via "return".
 *    [] trace2_cmd_name()        [test-tool.c:cmd_main()]
				return ut_k->ut_fn(argc - 1, argv + 1);

	int k;
 *    [] trace2_initialize()      [common-main.c:main()]

	int result;
 *    [] that "version", "start", ..., "exit", and "atexit" events are
 *    the PERF stream).
 * Test harness can confirm:
 *

 *    a CreateProcess(), WaitForSingleObject(), and exit()).
 *    [] the "cmd_name" event has been generated.
};
 * [] that the outer process has a single component SID (or depth "d0" in

	struct unit_test *ut_k;
 *
static int get_i(int *p_value, const char *data)
	if (argc)

	int k;
static int ut_005exec(int argc, const char **argv)
int cmd__trace2(int argc, const char **argv)
/* clang-format on */
 * [] the "code" field in the "exit" trace2 event.
	int k;
 * Test harness can confirm (on Windows):
/*
 * We further assume that if we return (rather than exit()), trace2_cmd_exit()



 */
 *    [] the "start" event has been generated.
	if (get_i(&rc, argv[0]))

	result = run_command_v_opt(argv, 0);
#define USAGE_PREFIX "test-tool trace2"

 * test-tool trace2 004child git -c alias.xyz=version xyz
		argv += 3;
}
	int rc;
/*
	     k < ARRAY_SIZE(ut_table);		\
 * [] the "name" field in the "cmd_name" trace2 event.
	 */
	return 0;
		die("expect <exit_code>");

static int ut_003error(int argc, const char **argv)
 *    in the PERF stream).
 * or replace the existing process.
}


