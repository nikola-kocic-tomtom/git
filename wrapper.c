		nonrelative_template = absolute_path(filename_template);
#ifdef XMALLOC_POISON
	}
			if (handle_nonblock(fd, POLLIN, errno))
 * the absence of bugs, large chunks can result in bad latencies when
		if (errno == EINTR)
static int access_error_is_ok(int err, unsigned flag)

			errno = EPERM;
	pfd.events = poll_events;

}
{
{
char *xgetcwd(void)
	if (ret < 0)
	if (len < num_x + suffix_len) {
}

	return rc;
 * Limit size of IO chunks, because huge chunks only cause pain.  OS X
	int rc = unlink(file);
	if (!ret)
#  define MAX_IO_SIZE MAX_IO_SIZE_DEFAULT
	if (close(fd))
		count -= loaded;
			filename_template = origtemplate;
	return git_mkstemps_mode(pattern, 0, mode);
		 * the next TMP_MAX values generated by adding 7777 to
 */
	}

/*
	}
{
		if (loaded == 0)
	}
	poll(&pfd, 1, -1);
}
static void *do_xmalloc(size_t size, int gentle)
		return nr;
	}
			    (uintmax_t)size, (uintmax_t)limit);

	if (unsigned_mult_overflows(nmemb, size))
	mode_t mode = 0;
	return (is_missing_file_error(err) ||
ssize_t xwrite(int fd, const void *buf, size_t len)
ssize_t pread_in_full(int fd, void *buf, size_t count, off_t offset)

 * to override this, if the definition of SSIZE_MAX given by the platform
}
	if (len > MAX_IO_SIZE)
		if (fp)
		ret = calloc(1, 1);
			return -1;
	if (strbuf_getcwd(&sb))
	char *p = buf;
	if (stat(filename, &st) < 0) {
	if (!ret && errno == EPERM) {
	/* We return the null string if we can't find a unique file name.  */
	return -1;
	while (1) {
		die_errno(_("could not close '%s'"), path);
int access_or_die(const char *path, int mode, unsigned flag)
	}
		ssize_t written = xwrite(fd, p, count);
int is_empty_or_missing_file(const char *filename)
	va_end(ap);
 */
		ret = malloc(1);

{
	}
static int memory_limit_check(size_t size, int gentle)

{
#define TMP_MAX 16384
}
		 */
{
	return total;
static void *do_xmallocz(size_t size, int gentle)
}
	if (!ret)
		}
	if (!rc || errno == ENOENT)
	return ret;
		return NULL;
	return do_xmallocz(size, 0);
		die_errno(_("unable to get current working directory"));
		die("Out of memory, realloc failed");
 */
	memset(ret, 0xA5, size);
		BUG("attempt to snprintf into too-small buffer");
	}
{
		return 0;
}

 * xwrite() is the same a write(), but it automatically restarts write()
{
int xsnprintf(char *dst, size_t max, const char *fmt, ...)
		 * VALUE are different with (module 2^32).
/**

	return ret;
	static const char letters[] =
		count -= loaded;
		else if ((oflag & O_WRONLY) == O_WRONLY)
# define MAX_IO_SIZE_DEFAULT (8*1024*1024)
}
}
{
		total += loaded;
	va_start(ap, oflag);
				continue;

	 * mode_t to avoid undefined behavior.
/**
				continue;
			error("attempting to allocate %"PRIuMAX" over limit %"PRIuMAX,
ssize_t write_in_full(int fd, const void *buf, size_t count)
		}
	if (len > MAX_IO_SIZE)

	for (;;) {
	va_list params;
			nonrelative_template);

#include "config.h"
			return total;
	ssize_t nr;
			return NULL;
	memory_limit_check(size * nmemb, 0);
 */
		if ((nr < 0) && (errno == EAGAIN || errno == EINTR))
{
{
{
	for (;;) {
	char *p = memchr(str, '\0', len);
{
	uint64_t value;
}
			if (errno == EINTR)
}
		fd = open(pattern, O_CREAT | O_EXCL | O_RDWR, mode);

	if (stream == NULL)

void sleep_millisec(int millisec)
	 */
	static const int num_letters = ARRAY_SIZE(letters) - 1;
	return NULL;
		int i;
		count -= written;
		if (loaded < 0)
{
/* Adapted from libiberty's mkstemp.c. */
	while (1) {
	assert(err);
			die_errno(_("could not open '%s' for reading"), path);

	}
# endif
	char *p = buf;
		else {
{
	strlcpy(origtemplate, filename_template, sizeof(origtemplate));
int git_mkstemps_mode(char *pattern, int suffix_len, int mode)
int git_mkstemp_mode(char *pattern, int mode)


#  define MAX_IO_SIZE SSIZE_MAX

	 * compatible with the argument type. Since integers are promoted to
		}
 */

		return 0;
{

		errno = saved_errno;

		errno = EINVAL;
			return -1;
		/*

				continue;
			continue;
	va_start(ap, fmt);
	struct strbuf sb = STRBUF_INIT;
	return warn_if_unremovable("unlink", file, unlink(file));


			nonrelative_template);
	if (!ret && !size)
	 * ints, we fetch the next argument as an int, and then cast it to a

int warn_on_fopen_errors(const char *path)
		len = MAX_IO_SIZE;
	if (ret && !access_error_is_ok(errno, flag))
	strlcpy(origtemplate, filename_template, sizeof(origtemplate));
		int saved_errno = errno;
	struct strbuf sb = STRBUF_INIT;
	 * Try TMP_MAX different filenames.
	ssize_t total = 0;
		/*
{

		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
#ifndef MAX_IO_SIZE
		BUG("your snprintf is broken");
		return -1;
	while (count > 0) {
		die_errno("Out of memory? fdopen failed");

			return fd;
}
	return ret;

	void *ret;

}
		else if (*mode == 'w' || *mode == 'a')
	fd = git_mkstemp_mode(filename_template, mode);
			continue;
{
	if (!ret && !size)
	pfd.fd = fd;
 */

		if (!filename_template[0])
{
	if (!ret)
	len = vsnprintf(dst, max, fmt, ap);
	struct stat st;
		if ((oflag & O_RDWR) == O_RDWR)

char *xstrndup(const char *str, size_t len)
# if defined(SSIZE_MAX) && (SSIZE_MAX < MAX_IO_SIZE_DEFAULT)

{
	int fd = xopen(path, O_WRONLY | O_CREAT | O_TRUNC, 0666);
		else
		"abcdefghijklmnopqrstuvwxyz"
		die_errno(_("could not write to '%s'"), path);
{

	ssize_t total = 0;
			if (handle_nonblock(fd, POLLOUT, errno))
	void *ret;
 * We pick 8 MiB as our default, but if the platform defines SSIZE_MAX
int access_or_warn(const char *path, int mode, unsigned flag)
	return do_xmallocz(size, 1);
			return -1;
}
		warn_on_inaccessible(path);
{
		die_errno("Unable to create temporary file '%s'",
	return warn_if_unremovable("rmdir", file, rmdir(file));
	return ret;
}
	return -1;
#endif
FILE *xfopen(const char *path, const char *mode)
		if (!unlink(path))
			return NULL;
	len = strlen(pattern);
	write_file_buf(path, sb.buf, sb.len);
	int fd, count;

		ret = realloc(ptr, 1);
}
		int saved_errno = errno;
	ssize_t total = 0;
	}
}
		if (*mode && mode[1] == '+')
{
	return xmemdupz(str, p ? p - str : len);
	 * Replace pattern's XXXXXX characters with randomness.
		const char *nonrelative_template;
	pattern[0] = '\0';
			limit = SIZE_MAX;
		die_errno(_("could not stat %s"), filename);
	int fd;
		die_errno(_("unable to access '%s'"), path);
}
}
		errno = EINVAL;
	/*
 * resort, we allow a port to pass via CFLAGS e.g. "-DMAX_IO_SIZE=value"
int xopen(const char *path, int oflag, ...)
}
		buf[len - 1] = 0;
void *xmallocz(size_t size)
		 * This is a random value.  It is only necessary that
FILE *fopen_for_writing(const char *path)
		if (gentle) {
	 */
		ssize_t loaded = xpread(fd, p, count, offset);

 * is broken.
		if (written < 0)
{
}

		}
{
	if (memory_limit_check(size, gentle))
	return stream;
{

		die("Out of memory, calloc failed");
	value = ((uint64_t)tv.tv_usec << 16) ^ tv.tv_sec ^ getpid();
 * operations with a recoverable error (EAGAIN and EINTR). xwrite() DOES NOT
 * GUARANTEE that "len" bytes is written even if the operation is successful.
	struct timeval tv;
			filename_template[i] = letters[v % num_letters];
	void *ret;
	char *filename_template;
		} else
}
}
		((flag & ACCESS_EACCES_OK) && err == EACCES));
	strbuf_release(&sb);
		len = MAX_IO_SIZE;
/*
}
	return ret;

int unlink_or_warn(const char *file)
	return S_ISGITLINK(mode) ? rmdir_or_warn(file) : unlink_or_warn(file);
{
	fd = mkstemp(filename_template);

	return ret;
	return len;

	return ret;
		return 0;
	if (ret)
	if (!ret) {

 * that is smaller than that, clip it to SSIZE_MAX, as a call to
}
		errno = saved_errno;
	ssize_t nr;
		}

}
}

int remove_or_warn(unsigned int mode, const char *file)
	va_start(params, fmt);
{
	gettimeofday(&tv, NULL);
 * operations with a recoverable error (EAGAIN and EINTR). xpread() DOES
 * operations with a recoverable error (EAGAIN and EINTR). xread()
	int ret = gethostname(buf, len);
		const char *nonrelative_template;
		/* Fill in the random bits. */

		uint64_t v = value;
 * xmemdupz() allocates (len + 1) bytes of memory, duplicates "len" bytes of
	if (errno != ENOENT && errno != ENOTDIR) {

# else
		else
		p += loaded;
		if (fd >= 0)
}
 * xread() is the same a read(), but it automatically restarts read()
		return -1;
		int fd = open(path, oflag, mode);
	filename_template = &pattern[len - num_x - suffix_len];
/*
		"0123456789";

			die_errno(_("could not open '%s' for writing"), path);

			die_errno(_("could not open '%s' for writing"), path);
{
int unlink_or_msg(const char *file, struct strbuf *err)
			break;
int xgethostname(char *buf, size_t len)
}
		die("data too large to fit into virtual memory space");
int xmkstemp_mode(char *filename_template, int mode)
char *xstrdup(const char *str)
{

		total += loaded;
		return nr;
	strbuf_complete_line(&sb);

	}
		mode = va_arg(ap, int);
			return fd;
	static size_t limit = 0;
	poll(NULL, 0, millisec);
			errno = ENOSPC;
}

	errno = err;
		for (i = 0; i < num_x; i++) {
		value += 7777;

ssize_t xread(int fd, void *buf, size_t len)
 * Various trivial helper wrappers around standard functions
	return ret;
	if (unsigned_add_overflows(size, 1)) {
	struct pollfd pfd;
		return -1;

}
 * read(2) or write(2) larger than that is allowed to fail.  As the last
	if (len >= max)

		if (fd >= 0)
	int ret = access(path, mode);
	 * va_arg() will have undefined behavior if the specified type is not
		 * Fatal error (EPERM, ENOSPC etc).



	/*
	char origtemplate[PATH_MAX];
	 */
	if (fd < 0) {
{
	if (len < 0)
{
		((char*)ret)[size] = 0;
ssize_t read_in_full(int fd, void *buf, size_t count)
			error("Out of memory, malloc failed (tried to allocate %lu bytes)",
		limit = git_env_ulong("GIT_ALLOC_LIMIT", 0);
	const char *p = buf;
}
static void warn_on_inaccessible(const char *path)
 * you decide to kill the process.
}
	if (oflag & O_CREAT)
	return 0;
	return do_xmalloc(size, 0);
void *xcalloc(size_t nmemb, size_t size)
}

 * xpread() is the same as pread(), but it automatically restarts pread()

{
	if (fp)
{
	if (len > MAX_IO_SIZE)

 * DOES NOT GUARANTEE that "len" bytes is read even if the data is available.
			      (uintmax_t)size, (uintmax_t)limit);
	warning_errno(_("unable to access '%s'"), path);
FILE *xfdopen(int fd, const char *mode)
			return fp;
#include "cache.h"
FILE *fopen_or_warn(const char *path, const char *mode)
			ret = fopen(path, "w");
}
{
	FILE *stream = fdopen(fd, mode);
			filename_template = origtemplate;
		return nr;
}

		if (!written) {
static int warn_if_unremovable(const char *op, const char *file, int rc)
	va_end(ap);
		} else
void *xrealloc(void *ptr, size_t size)
		nr = write(fd, buf, len);
void write_file(const char *path, const char *fmt, ...)

{
	return fd;
		warn_on_inaccessible(path);
		 * It doesn't make sense to loop.
		p += loaded;
			die_errno(_("could not open '%s' for reading and writing"), path);
		if (errno != EEXIST)
{
#endif
 * NOT GUARANTEE that "len" bytes is read even if the data is available.
/*
		die("Out of memory, strdup failed");
}
	return fd;
	 * specify whether the buffer will be null-terminated, so to
	 * no need to check for errors, here;

{

			die("Out of memory, malloc failed (tried to allocate %lu bytes)",
		if (nr < 0) {
	return total;
		return fp;
	return ret;
			v /= num_letters;

	return strbuf_detach(&sb, NULL);
	return total;
/*
	FILE *ret = fopen(path, "w");
	 * a subsequent read/write will detect unrecoverable errors
	static const int num_x = ARRAY_SIZE(x_pattern) - 1;

void *xmallocz_gently(size_t size)
 *

void write_file_buf(const char *path, const char *buf, size_t len)
	}
			error("Data too large to fit into virtual memory space.");

	va_end(params);
	ret = malloc(size);
	strbuf_addf(err, "unable to unlink '%s': %s",
			return -1;
	/*
}
{
		if (errno == EINTR)
		    file, strerror(errno));
{
	}

#undef TMP_MAX

	err = errno;
	int ret = dup(fd);
			    (unsigned long)size);
			return total;
		if (loaded == 0)
	}
	 * be safe, do it ourselves.
			return 1;
	return !st.st_size;
}
	static const char x_pattern[] = "XXXXXX";
			die("Data too large to fit into virtual memory space.");
		if (gentle) {

 * xopen() is the same as open(), but it die()s if the open() fails.
 * and returns a pointer to the allocated memory. If the allocation fails,
	/*
		if (errno == ENOENT)
	if (!rc || errno == ENOENT)

	if (write_in_full(fd, buf, len) < 0)
 * the program dies.

}
	/* mkstemp is just mkstemps with no suffix */
	size_t len;
	if (fd < 0) {
	return 1;

	}
	warning_errno("unable to %s '%s'", op, file);
		FILE *fp = fopen(path, mode);
	int len;
	}
	FILE *fp = fopen(path, mode);
	if (!ret && (!nmemb || !size))
	if (!limit) {
	}
}
	 */
	char *ret = strdup(str);
	return ret;
				continue;

		total += written;


	ret = calloc(nmemb, size);
		nr = pread(fd, buf, len, offset);

			die_errno(_("could not open '%s' for reading"), path);

{
int rmdir_or_warn(const char *file)
		if (!gentle)

	int ret = access(path, mode);
		else
	if (ret && !access_error_is_ok(errno, flag))
	return 0;
/*
	va_list ap;
	}
		p += written;

 */
		 */
	return memcpy(xmallocz(len), data, len);
		len = MAX_IO_SIZE;
{
	if (err != EAGAIN && err != EWOULDBLOCK)
		die_errno("Unable to create temporary file '%s'",
}
 * "data" to the allocated memory, zero terminates the allocated memory,

	if (!ret)
{
	if (strncmp(&pattern[len - num_x - suffix_len], x_pattern, num_x)) {


static int handle_nonblock(int fd, short poll_events, int err)
{
}
}
		if (strlen(filename_template) != strlen(origtemplate))
		if (loaded < 0)
	 * If the full hostname doesn't fit in buf, POSIX does not

	strbuf_vaddf(&sb, fmt, params);
			die("attempting to allocate %"PRIuMAX" over limit %"PRIuMAX,
	va_list ap;

	while (count > 0) {
	}
	void *ret;
void *xmalloc(size_t size)
 */
			return -1;
	}
	ret = realloc(ptr, size);
		if (!limit)
 * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in
int xdup(int fd)

{
		ssize_t loaded = xread(fd, p, count);
		offset += loaded;
	ret = do_xmalloc(size + 1, gentle);
	while (count > 0) {

 * xfopen() is the same as fopen(), but it die()s if the fopen() fails.
			die_errno(_("could not open '%s' for reading and writing"), path);
		if (nr < 0) {
	while (1) {
		die_errno("dup failed");
	int err;
			continue;
	ssize_t nr;
	int fd;
		nr = read(fd, buf, len);
			      (unsigned long)size);
int xmkstemp(char *filename_template)

	warn_on_fopen_errors(path);
	char origtemplate[PATH_MAX];

			if (errno == EINTR)
	memory_limit_check(size, 0);
	for (count = 0; count < TMP_MAX; ++count) {
	if (size > limit) {
		nonrelative_template = absolute_path(filename_template);

ssize_t xpread(int fd, void *buf, size_t len, off_t offset)
void *xmemdupz(const void *data, size_t len)
}
